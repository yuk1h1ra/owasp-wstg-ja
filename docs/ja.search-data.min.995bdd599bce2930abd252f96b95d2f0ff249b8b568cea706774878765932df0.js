'use strict';(function(){const indexCfg={encode:false,tokenize:function(str){return str.replace(/[\x00-\x7F]/g,'').split('');}};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/ja/docs/0-Foreword/','title':"0 Foreword",'section':"Docs",'content':"Foreword by Eoin Keary #  The problem of insecure software is perhaps the most important technical challenge of our time. The dramatic rise of web applications enabling business, social networking etc has only compounded the requirements to establish a robust approach to writing and securing our Internet, Web Applications and Data.\nAt the Open Web Application Security Project® (OWASP®), we\u0026rsquo;re trying to make the world a place where insecure software is the anomaly, not the norm. The OWASP Testing Guide has an important role to play in solving this serious issue. It is vitally important that our approach to testing software for security issues is based on the principles of engineering and science. We need a consistent, repeatable and defined approach to testing web applications. A world without some minimal standards in terms of engineering and technology is a world in chaos.\nIt goes without saying that you can\u0026rsquo;t build a secure application without performing security testing on it. Testing is part of a wider approach to build a secure system. Many software development organizations do not include security testing as part of their standard software development process. What is even worse is that many security vendors deliver testing with varying degrees of quality and rigor.\nSecurity testing, by itself, isn\u0026rsquo;t a particularly good stand alone measure of how secure an application is, because there are an infinite number of ways that an attacker might be able to make an application break, and it simply isn\u0026rsquo;t possible to test them all. We can\u0026rsquo;t hack ourselves secure as we only have a limited time to test and defend where an attacker does not have such constraints.\nIn conjunction with other OWASP projects such as the Code Review Guide, the Development Guide and tools such as OWASP ZAP, this is a great start towards building and maintaining secure applications. This Testing Guide will show you how to verify the security of your running application. I highly recommend using these guides as part of your application security initiatives.\nWhy OWASP? #  Creating a guide like this is a huge undertaking, requiring the expertise of hundreds of people around the world. There are many different ways to test for security flaws and this guide captures the consensus of the leading experts on how to perform this testing quickly, accurately, and efficiently. OWASP gives like minded security folks the ability to work together and form a leading practice approach to a security problem.\nThe importance of having this guide available in a completely free and open way is important for the foundation\u0026rsquo;s mission. It gives anyone the ability to understand the techniques used to test for common security issues. Security should not be a black art or closed secret that only a few can practice. It should be open to all and not exclusive to security practitioners but also QA, Developers and Technical Managers. The project to build this guide keeps this expertise in the hands of the people who need it - you, me and anyone that is involved in building software.\nThis guide must make its way into the hands of developers and software testers. There are not nearly enough application security experts in the world to make any significant dent in the overall problem. The initial responsibility for application security must fall on the shoulders of the developers because they write the code. It shouldn\u0026rsquo;t be a surprise that developers aren\u0026rsquo;t producing secure code if they\u0026rsquo;re not testing for it or consider the types of bugs which introduce vulnerability.\nKeeping this information up to date is a critical aspect of this guide project. By adopting the wiki approach, the OWASP community can evolve and expand the information in this guide to keep pace with the fast moving application security threat landscape.\nThis Guide is a great testament to the passion and energy our members and project volunteers have for this subject. It shall certainly help to change the world a line of code at a time.\nTailoring and Prioritizing #  You should adopt this guide in your organization. You may need to tailor the information to match your organization\u0026rsquo;s technologies, processes, and organizational structure.\nIn general there are several different roles within organizations that may use this guide:\n Developers should use this guide to ensure that they are producing secure code. These tests should be a part of normal code and unit testing procedures. Software testers and QA should use this guide to expand the set of test cases they apply to applications. Catching these vulnerabilities early saves considerable time and effort later. Security specialists should use this guide in combination with other techniques as one way to verify that no security holes have been missed in an application. Project Managers should consider the reason this guide exists and that security issues are manifested via bugs in code and design.  The most important thing to remember when performing security testing is to continuously re-prioritize. There are an infinite number of possible ways that an application could fail, and organizations always have limited testing time and resources. Be sure time and resources are spent wisely. Try to focus on the security holes that are a real risk to your business. Try to contextualize risk in terms of the application and its use cases.\nThis guide is best viewed as a set of techniques that you can use to find different types of security holes. But not all the techniques are equally important. Try to avoid using the guide as a checklist, new vulnerabilities are always manifesting and no guide can be an exhaustive list of \u0026ldquo;things to test for\u0026rdquo;, but rather a great place to start.\nThe Role of Automated Tools #  There are a number of companies selling automated security analysis and testing tools. Remember the limitations of these tools so that you can use them for what they\u0026rsquo;re good at. As Michael Howard put it at the 2006 OWASP AppSec Conference in Seattle, \u0026ldquo;Tools do not make software secure! They help scale the process and help enforce policy.\u0026rdquo;\nMost importantly, these tools are generic - meaning that they are not designed for your custom code, but for applications in general. That means that while they can find some generic problems, they do not have enough knowledge of your application to allow them to detect most flaws. In my experience, the most serious security issues are the ones that are not generic, but deeply intertwined in your business logic and custom application design.\nThese tools can also be very useful, since they do find lots of potential issues. While running the tools doesn\u0026rsquo;t take much time, each one of the potential problems takes time to investigate and verify. If the goal is to find and eliminate the most serious flaws as quickly as possible, consider whether your time is best spent with automated tools or with the techniques described in this guide. Still, these tools are certainly part of a well-balanced application security program. Used wisely, they can support your overall processes to produce more secure code.\nCall to Action #  If you\u0026rsquo;re building, designing or testing software, I strongly encourage you to get familiar with the security testing guidance in this document. It is a great road map for testing the most common issues that applications are facing today, but it is not exhaustive. If you find errors, please add a note to the discussion page or make the change yourself. You\u0026rsquo;ll be helping thousands of others who use this guide.\nPlease consider joining us as an individual or corporate member so that we can continue to produce materials like this testing guide and all the other great projects at OWASP.\nThank you to all the past and future contributors to this guide, your work will help to make applications worldwide more secure.\n\u0026ndash;Eoin Keary, OWASP Board Member, April 19, 2013\nOpen Web Application Security Project and OWASP are registered trademarks of the OWASP Foundation, Inc.\n"});index.add({'id':1,'href':'/ja/docs/3-The_OWASP_Testing_Framework/0-The_Web_Security_Testing_Framework/','title':"0 the Web Security Testing Framework",'section':"3 The OWASP Testing Framework",'content':"The Web Security Testing Framework #  Overview #  This section describes a typical testing framework that can be developed within an organization. It can be seen as a reference framework comprised of techniques and tasks that are appropriate at various phases of the software development life cycle (SDLC). Companies and project teams can use this model to develop their own testing framework, and to scope testing services from vendors. This framework should not be seen as prescriptive, but as a flexible approach that can be extended and molded to fit an organization\u0026rsquo;s development process and culture.\nThis section aims to help organizations build a complete strategic testing process, and is not aimed at consultants or contractors who tend to be engaged in more tactical, specific areas of testing.\nIt is critical to understand why building an end-to-end testing framework is crucial to assessing and improving software security. In Writing Secure Code, Howard and LeBlanc note that issuing a security bulletin costs Microsoft at least $100,000, and it costs their customers collectively far more than that to implement the security patches. They also note that the US government\u0026rsquo;s CyberCrime web site details recent criminal cases and the loss to organizations. Typical losses far exceed USD $100,000.\nWith economics like this, it is little wonder why software vendors move from solely performing black-box security testing, which can only be performed on applications that have already been developed, to concentrating on testing in the early cycles of application development, such as during definition, design, and development.\nMany security practitioners still see security testing in the realm of penetration testing. As discussed in the previous chapter, while penetration testing has a role to play, it is generally inefficient at finding bugs and relies excessively on the skill of the tester. It should only be considered as an implementation technique, or to raise awareness of production issues. To improve the security of applications, the security quality of the software must be improved. That means testing security during the definition, design, development, deployment, and maintenance stages, and not relying on the costly strategy of waiting until code is completely built.\nAs discussed in the introduction of this document, there are many development methodologies, such as the Rational Unified Process, eXtreme and Agile development, and traditional waterfall methodologies. The intent of this guide is to suggest neither a particular development methodology, nor provide specific guidance that adheres to any particular methodology. Instead, we are presenting a generic development model, and the reader should follow it according to their company process.\nThis testing framework consists of activities that should take place:\n Before development begins, During definition and design, During development, During deployment, and During maintenance and operations.  Phase 1 Before Development Begins #  Phase 1.1 Define a SDLC #  Before application development starts, an adequate SDLC must be defined where security is inherent at each stage.\nPhase 1.2 Review Policies and Standards #  Ensure that there are appropriate policies, standards, and documentation in place. Documentation is extremely important as it gives development teams guidelines and policies that they can follow. People can only do the right thing if they know what the right thing is.\nIf the application is to be developed in Java, it is essential that there is a Java secure coding standard. If the application is to use cryptography, it is essential that there is a cryptography standard. No policies or standards can cover every situation that the development team will face. By documenting the common and predictable issues, there will be fewer decisions that need to be made during the development process.\nPhase 1.3 Develop Measurement and Metrics Criteria and Ensure Traceability #  Before development begins, plan the measurement program. By defining criteria that need to be measured, it provides visibility into defects in both the process and product. It is essential to define the metrics before development begins, as there may be a need to modify the process in order to capture the data.\nPhase 2 During Definition and Design #  Phase 2.1 Review Security Requirements #  Security requirements define how an application works from a security perspective. It is essential that the security requirements are tested. Testing in this case means testing the assumptions that are made in the requirements and testing to see if there are gaps in the requirements definitions.\nFor example, if there is a security requirement that states that users must be registered before they can get access to the whitepapers section of a website, does this mean that the user must be registered with the system or should the user be authenticated? Ensure that requirements are as unambiguous as possible.\nWhen looking for requirements gaps, consider looking at security mechanisms such as:\n User management Authentication Authorization Data confidentiality Integrity Accountability Session management Transport security Tiered system segregation Legislative and standards compliance (including privacy, government, and industry standards)  Phase 2.2 Review Design and Architecture #  Applications should have a documented design and architecture. This documentation can include models, textual documents, and other similar artifacts. It is essential to test these artifacts to ensure that the design and architecture enforce the appropriate level of security as defined in the requirements.\nIdentifying security flaws in the design phase is not only one of the most cost-efficient places to identify flaws, but can be one of the most effective places to make changes. For example, if it is identified that the design calls for authorization decisions to be made in multiple places, it may be appropriate to consider a central authorization component. If the application is performing data validation at multiple places, it may be appropriate to develop a central validation framework (ie, fixing input validation in one place, rather than in hundreds of places, is far cheaper).\nIf weaknesses are discovered, they should be given to the system architect for alternative approaches.\nPhase 2.3 Create and Review UML Models #  Once the design and architecture is complete, build Unified Modeling Language (UML) models that describe how the application works. In some cases, these may already be available. Use these models to confirm with the systems designers an exact understanding of how the application works. If weaknesses are discovered, they should be given to the system architect for alternative approaches.\nPhase 2.4 Create and Review Threat Models #  Armed with design and architecture reviews and the UML models explaining exactly how the system works, undertake a threat modeling exercise. Develop realistic threat scenarios. Analyze the design and architecture to ensure that these threats have been mitigated, accepted by the business, or assigned to a third party, such as an insurance firm. When identified threats have no mitigation strategies, revisit the design and architecture with the systems architect to modify the design.\nPhase 3 During Development #  Theoretically, development is the implementation of a design. However, in the real world, many design decisions are made during code development. These are often smaller decisions that were either too detailed to be described in the design, or issues where no policy or standard guidance was offered. If the design and architecture were not adequate, the developer will be faced with many decisions. If there were insufficient policies and standards, the developer will be faced with even more decisions.\nPhase 3.1 Code Walkthrough #  The security team should perform a code walkthrough with the developers, and in some cases, the system architects. A code walkthrough is a high-level look at the code during which the developers can explain the logic and flow of the implemented code. It allows the code review team to obtain a general understanding of the code, and allows the developers to explain why certain things were developed the way they were.\nThe purpose is not to perform a code review, but to understand at a high level the flow, the layout, and the structure of the code that makes up the application.\nPhase 3.2 Code Reviews #  Armed with a good understanding of how the code is structured and why certain things were coded the way they were, the tester can now examine the actual code for security defects.\nStatic code reviews validate the code against a set of checklists, including:\n Business requirements for availability, confidentiality, and integrity; OWASP Guide or Top 10 Checklists for technical exposures (depending on the depth of the review); Specific issues relating to the language or framework in use, such as the Scarlet paper for PHP or Microsoft Secure Coding checklists for ASP.NET; and Any industry-specific requirements, such as Sarbanes-Oxley 404, COPPA, ISO/IEC 27002, APRA, HIPAA, Visa Merchant guidelines, or other regulatory regimes.  In terms of return on resources invested (mostly time), static code reviews produce far higher quality returns than any other security review method and rely least on the skill of the reviewer. However, they are not a silver bullet and need to be considered carefully within a full-spectrum testing regime.\nFor more details on OWASP checklists, please refer to the latest edition of the OWASP Top 10.\nPhase 4 During Deployment #  Phase 4.1 Application Penetration Testing #  Having tested the requirements, analyzed the design, and performed code review, it might be assumed that all issues have been caught. Hopefully this is the case, but penetration testing the application after it has been deployed provides an additional check to ensure that nothing has been missed.\nPhase 4.2 Configuration Management Testing #  The application penetration test should include an examination of how the infrastructure was deployed and secured. It is important to review configuration aspects, no matter how small, to ensure that none are left at a default setting that may be vulnerable to exploitation.\nPhase 5 During Maintenance and Operations #  Phase 5.1 Conduct Operational Management Reviews #  There needs to be a process in place which details how the operational side of both the application and infrastructure is managed.\nPhase 5.2 Conduct Periodic Health Checks #  Monthly or quarterly health checks should be performed on both the application and infrastructure to ensure no new security risks have been introduced and that the level of security is still intact.\nPhase 5.3 Ensure Change Verification #  After every change has been approved and tested in the QA environment and deployed into the production environment, it is vital that the change is checked to ensure that the level of security has not been affected by the change. This should be integrated into the change management process.\nA Typical SDLC Testing Workflow #  The following figure shows a typical SDLC Testing Workflow.\n Figure 3-1: Typical SDLC testing workflow\n"});index.add({'id':2,'href':'/ja/docs/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies/','title':"1 Penetration Testing Methodologies",'section':"3 The OWASP Testing Framework",'content':"Penetration Testing Methodologies #  Summary #    Penetration Testing Methodologies   Summary  OWASP Testing Guides  Penetration Testing Execution Standard  PCI Penetration Testing Guide   PCI DSS Penetration Testing Guidance  PCI DSS Penetration Testing Requirements    Penetration Testing Framework  Technical Guide to Information Security Testing and Assessment  Open Source Security Testing Methodology Manual  References    OWASP Testing Guides #  In terms of technical security testing execution, the OWASP testing guides are highly recommended. Depending on the types of the applications, the testing guides are listed below for the web/cloud services, Mobile app (Android/iOS), or IoT firmware respectively.\n  OWASP Web Security Testing Guide  OWASP Mobile Security Testing Guide  OWASP Firmware Security Testing Methodology  Penetration Testing Execution Standard #  Penetration Testing Execution Standard (PTES) defines penetration testing as 7 phases. Particularly, PTES Technical Guidelines give hands-on suggestions on testing procedures, and recommendation for security testing tools.\n Pre-engagement Interactions Intelligence Gathering Threat Modeling Vulnerability Analysis Exploitation Post Exploitation Reporting   PTES Technical Guidelines\nPCI Penetration Testing Guide #  Payment Card Industry Data Security Standard (PCI DSS) Requirement 11.3 defines the penetration testing. PCI also defines Penetration Testing Guidance.\nPCI DSS Penetration Testing Guidance #  The PCI DSS Penetration testing guideline provides guidance on the following:\n Penetration Testing Components Qualifications of a Penetration Tester Penetration Testing Methodologies Penetration Testing Reporting Guidelines  PCI DSS Penetration Testing Requirements #  The PCI DSS requirement refer to Payment Card Industry Data Security Standard (PCI DSS) Requirement 11.3\n Based on industry-accepted approaches Coverage for CDE and critical systems Includes external and internal testing Test to validate scope reduction Application-layer testing Network-layer tests for network and OS   PCI DSS Penetration Test Guidance\nPenetration Testing Framework #  The Penetration Testing Framework (PTF) provides comprehensive hands-on penetration testing guide. It also lists usages of the security testing tools in each testing category. The major area of penetration testing includes:\n Network Footprinting (Reconnaissance) Discovery \u0026amp; Probing Enumeration Password cracking Vulnerability Assessment AS/400 Auditing Bluetooth Specific Testing Cisco Specific Testing Citrix Specific Testing Network Backbone Server Specific Tests VoIP Security Wireless Penetration Physical Security Final Report - template   Penetration Testing Framework\nTechnical Guide to Information Security Testing and Assessment #  Technical Guide to Information Security Testing and Assessment (NIST 800-115) was published by NIST, it includes some assessment techniques listed below.\n Review Techniques Target Identification and Analysis Techniques Target Vulnerability Validation Techniques Security Assessment Planning Security Assessment Execution Post-Testing Activities  The NIST 800-115 can be accessed here\nOpen Source Security Testing Methodology Manual #  The Open Source Security Testing Methodology Manual (OSSTMM) is a methodology to test the operational security of physical locations, workflow, human security testing, physical security testing, wireless security testing, telecommunication security testing, data networks security testing and compliance. OSSTMM can be supporting reference of ISO 27001 instead of a hands-on or technical application penetration testing guide.\nOSSTMM includes the following key sections:\n Security Analysis Operational Security Metrics Trust Analysis Work Flow Human Security Testing Physical Security Testing Wireless Security Testing Telecommunications Security Testing Data Networks Security Testing Compliance Regulations Reporting with the STAR (Security Test Audit Report)   Open Source Security Testing Methodology Manual\nReferences #    PCI Data Security Standard - Penetration TestingGuidance  PTES Standard  Open Source Security Testing Methodology Manual (OSSTMM)  Technical Guide to Information Security Testing and Assessment NIST SP 800-115  HIPAA Security Testing Assessment 2012  Penetration Testing Framework 0.59  OWASP Mobile Security Testing Guide  Security Testing Guidelines for Mobile Apps  Kali Linux  Information Supplement: Requirement 11.3 Penetration Testing  "});index.add({'id':3,'href':'/ja/docs/3-The_OWASP_Testing_Framework/','title':"3 The OWASP Testing Framework",'section':"Docs",'content':"The OWASP Testing Framework #  3.1 The Web Security Testing Framework\n3.2 Phase 1 Before Development Begines\n3.3 Phase 2 During Definition and Design\n3.4 Phase 3 During Development\n3.5 Phase 4 During Deployment\n3.6 Phase 5 During Maintenance and Operations\n3.7 A Typical SDLC Testing Workflow\n3.8 Penetration Testing Methodologies\n"});index.add({'id':4,'href':'/ja/menu/','title':"Index",'section':"OWASP WSTG JP",'content':"  OWASP WSTG    0-Foreword\n   3-The_OWASP_Testing_Framework\n [0-The_Web_Security_Tesing_Framework]({{ relref \u0026ldquo;/docs/3-The_OWASP_Testing_Framework/0-The_Web_Security_Testing_Framework.md\u0026rdquo; }}) [1-Penetration_Testing_Methodologies]({{ relref \u0026ldquo;/docs/3-The_OWASP_Testing_Framework/1-Penetration_Testing_Methodologies.md\u0026rdquo; }})      "});})();